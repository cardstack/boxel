{
  "data": {
    "meta": {
      "adoptsFrom": {
        "name": "Statement",
        "module": "../statement"
      }
    },
    "type": "card",
    "attributes": {
      "content": "# Enum Fields and Field Configuration API\n\nBoxel provides powerful mechanisms for creating constrained fields with enumerated values and per-instance field configuration.\n\n## enumField Factory\n\n### Overview\n\nThe `enumField` factory creates a FieldDef subclass with a constrained set of allowed values and a default edit experience (dropdown) powered by Boxel UI. This enables consistent, type-safe enumerations for primitive fields.\n\n### Basic Usage\n\n**Import:**\n```gts\nimport { enumField } from 'https://cardstack.com/base/card-api';\nimport StringField from 'https://cardstack.com/base/string';\n```\n\n**Simple Enum:**\n```gts\nconst PriorityField = enumField(StringField, {\n  options: ['Highest', 'High', 'Medium', 'Low', 'Lowest'],\n});\n\nclass Task extends CardDef {\n  @field priority = contains(PriorityField);\n}\n// PriorityField has edit format that is a dropdown with the enum values\n```\n\n### Rich Options with Labels and Icons\n\nFor enhanced user experience, you can provide rich option objects with custom labels and icons:\n\n```gts\nimport ArrowUpIcon from '@cardstack/boxel-icons/arrow-up';\nimport MinusIcon from '@cardstack/boxel-icons/minus';\nimport ArrowDownIcon from '@cardstack/boxel-icons/arrow-down';\n\nconst PriorityField = enumField(StringField, {\n  options: [\n    { value: 'high', label: 'High', icon: ArrowUpIcon },\n    { value: 'medium', label: 'Medium', icon: MinusIcon },\n    { value: 'low', label: 'Low', icon: ArrowDownIcon },\n  ],\n});\n\nclass Task extends CardDef {\n  @field priority = contains(PriorityField);\n}\n// Edit format renders a dropdown with labeled options and icons\n// Selected trigger shows the chosen label and icon\n```\n\n### API Surface\n\n**Signature:**\n```typescript\nenumField(BaseField, { options, displayName?, icon? }) -> FieldDefConstructor\n```\n\n**Parameters:**\n- `BaseField`: A primitive FieldDefConstructor (e.g., StringField, NumberField)\n- `options`: Array of allowed values as primitives or rich objects `{ value, label?, icon? }`\n- `displayName?`: Optional custom display name for the field class\n- `icon?`: Optional icon for the field class\n\n**Returned Class Properties:**\n- `static enumOptions`: Readonly array of allowed values as provided\n- `static isEnumField = true`: Marker for validation and helpers\n- `static edit`: Default editor using BoxelSelect dropdown\n\n### Introspection Helpers\n\n**enumValues Helper:**\n\nAlways returns an array of primitive values, extracting `option.value` when rich options are configured:\n\n```gts\n<template>\n  {{enumValues @model 'priority'}}\n  {{! Returns: ['high', 'medium', 'low'] }}\n</template>\n```\n\n**enumOptions Helper:**\n\nAlways returns normalized rich option objects `{ value, label, icon? }` for use in templates and tests:\n\n```gts\n<template>\n  {{enumOptions @model 'priority'}}\n  {{! Returns: [{ value: 'high', label: 'High', icon: ArrowUpIcon }, ...] }}\n</template>\n```\n\n### Editing Behavior\n\n- Uses `BoxelSelect` from `@cardstack/boxel-ui/components` for the editor\n- Maps options to select items: label is `String(value)` or provided label\n- Value is the primitive for data storage\n- Defines an atom format that renders the selected option's label and optional icon\n- Uses the enum field's atom view for both select trigger and option row content\n- Respects `@canEdit`; when false, renders a disabled select\n\n### Validation\n\nEnum fields enforce allowed values when setting field values:\n\n- **Detection**: If `field.card.isEnumField`, validation is triggered\n- **Comparison**: Primitive comparison by value\n- **Implementation**: Check in `Contains.validate` to reject values not in `card.enumOptions` when `isEnumField` is true\n\n### Serialization and Querying\n\n- **Serialization**: Primitive enums serialize as primitives via the base field's serializer\n- **Querying**: Query behavior delegates to `getQueryableValue` of the base field type\n- Enum wrapping does not change query shape\n\n## Field Configuration API\n\n### Overview\n\nPer-instance field configuration provides a consistent mechanism for computing configuration for fields (e.g., options, palettes, constraints) while keeping the parent instance private and offering a safe, reactive API.\n\n### API Summary\n\n**Single, Consistent Key: `configuration`**\n\n**Field Definition (FieldDef):**\n```gts\nstatic configuration?: ConfigurationInput<any>\n```\n\n**Field Usage:**\n```gts\ncontains(Field, { configuration?: ConfigurationInput<ParentInstance> })\ncontainsMany(Field, { configuration?: ConfigurationInput<ParentInstance> })\nlinksTo(Card, { configuration?: ConfigurationInput<ParentInstance> })\nlinksToMany(Card, { configuration?: ConfigurationInput<ParentInstance> })\n```\n\n**Where:**\n```typescript\nConfigurationInput<T> = FieldConfiguration | ((self: Readonly<T>) => FieldConfiguration | undefined)\n```\n\n### Configuration Sources and Merging\n\nBoth configuration sources (FieldDef and contains/linksTo) are computed and merged:\n\n**Merge Rules:**\n- Deterministic order: `fromFieldDef` → `fromFieldUsage`\n- Shallow merge by default (object spread semantics)\n- One-level deep merge for nested objects\n- Arrays are replaced rather than concatenated\n- `undefined` values treated as \"absent\" and don't overwrite existing values\n- If a configuration function throws `NotLoaded`, catch and treat fragment as undefined for current render\n\n### Function Signature and NotLoaded Handling\n\nConfiguration functions have the same signature in both places:\n\n```typescript\n(self: Readonly<T>) => FieldConfiguration | undefined\n```\n\n**Runtime handles reactivity and NotLoaded:**\n- Before invocation, calls `entangleWithCardTracking(self)`\n- Invokes function inside try/catch\n- If accessing `self.someLink` throws `NotLoaded`, treats fragment as undefined for current render\n- Relies on re-render when links load\n- No special context object or `read()` wrapper required\n\n### FieldConfiguration Shape\n\nEach field type defines and validates its own schema. Suggested namespacing pattern:\n\n```typescript\n{\n  validate?: { min?: number; max?: number },\n  presentation?: { palette?: string[] },\n  options?: (primitive | { value; label?; icon? })[]\n}\n```\n\nThe runtime treats FieldConfiguration as an opaque object; the field class interprets it.\n\n### Resolution and Merge\n\n`resolveFieldConfiguration(field, instance)` function:\n\n1. Calls `entangleWithCardTracking(instance)` for reactive recomputation\n2. Computes configuration fragments:\n   - `fromFieldDef`: Evaluates `field.card.constructor.configuration` if present\n   - `fromFieldUsage`: Evaluates `field.configuration` stored by contains/linksTo\n3. Merges available fragments to produce effective configuration\n\n**Caching:**\n- Optionally cache by `(instance, fieldName)` in a WeakMap\n- Invalidate on `notifyCardTracking(instance)` to recompute on next access\n\n### Consumption in Components\n\nEditors and atoms receive merged configuration directly as `@configuration` argument:\n\n```gts\nclass ColorPaletteField extends FieldDef {\n  static edit = class Edit extends Component<typeof this> {\n    <template>\n      {{#each (@configuration.presentation.palette ?? []) as |color|}}\n        <span class='swatch' style={{concat 'background:' color}} />\n      {{/each}}\n    </template>\n  };\n}\n```\n\n**Key Points:**\n- All field/card format components (isolated, embedded, fitted, edit, atom) can read `@configuration`\n- Parent instance is NOT provided to components—only `@configuration`\n- Configuration is intentionally opaque; field authors define the shape\n- Preferred pattern: use injected `@configuration` arg instead of helpers\n\n### Examples\n\n**FieldDef-level Configuration (function form):**\n\n```gts\nclass ColorPaletteField extends FieldDef {\n  static configuration: ConfigurationInput<Card> = function(self) {\n    return {\n      presentation: { palette: self.theme?.palette },\n    };\n  };\n}\n\nclass Card extends CardDef {\n  @field theme = linksTo(Theme);\n  @field color = contains(ColorPaletteField);\n}\n```\n\n**Parent-level Configuration Merged with FieldDef:**\n\n```gts\nclass Card extends CardDef {\n  @field theme = linksTo(Theme);\n  @field color = contains(ColorPaletteField, {\n    configuration: { presentation: { palette: ['red', 'blue'] } },\n  });\n  // Effective configuration merges:\n  //   ColorPaletteField.configuration → contains(...).configuration\n}\n```\n\n**Dynamic Options from Parent Card:**\n\n```gts\nclass CrmApp extends CardDef {\n  @field globalPriorityOptions = containsMany(StringField);\n}\n\nclass Task extends CardDef {\n  @field crmApp = linksTo(CrmApp);\n  @field priority = contains(PriorityField);\n}\n\nconst PriorityField = enumField(StringField, {\n  options: function(self) {\n    return self.crmApp?.globalPriorityOptions;\n  }\n});\n```\n\n**Validation Based on Merged Configuration:**\n\n```gts\nclass ColorPaletteField extends FieldDef {\n  validate(instance: BaseDef, value: string | null) {\n    let cfg = resolveFieldConfiguration(this, instance);\n    let palette = cfg?.presentation?.palette ?? [];\n    if (value == null) return value;\n    if (!palette.includes(value))\n      throw new Error('color not allowed by palette');\n    return value;\n  }\n}\n```\n\n### Consuming @configuration in Custom Field Components\n\n**Simple Palette Consumer:**\n\n```gts\nimport { FieldDef, Component } from 'https://cardstack.com/base/card-api';\n\nexport class ColorField extends FieldDef {\n  static edit = class Edit extends Component<typeof this> {\n    // Normalize to array to keep template simple\n    get palette(): string[] {\n      return ((this.args.configuration as any)?.presentation?.palette ??\n        []) as string[];\n    }\n\n    <template>\n      {{#if this.palette.length}}\n        <ul class='color-palette' data-test-color-palette>\n          {{#each this.palette as |color|}}\n            <li\n              class='swatch'\n              style={{concat 'background:' color}}\n              data-test-swatch={{color}}\n            />\n          {{/each}}\n        </ul>\n      {{else}}\n        <em data-test-no-palette>palette loading or not configured</em>\n      {{/if}}\n    </template>\n  };\n}\n```\n\n**Options for Select-like Field:**\n\n```gts\nimport { FieldDef, Component } from 'https://cardstack.com/base/card-api';\n\ntype Option = string | { value: string; label?: string };\n\nexport class SelectField extends FieldDef {\n  static edit = class Edit extends Component<typeof this> {\n    get options(): { value: string; label: string }[] {\n      let raw = (this.args.configuration as any)?.options as\n        | Option[]\n        | undefined;\n      if (!raw) return [];\n      return raw.map((o) =>\n        typeof o === 'string'\n          ? { value: o, label: o }\n          : { value: o.value, label: o.label ?? o.value },\n      );\n    }\n\n    <template>\n      <select data-test-select>\n        {{#each this.options as |opt|}}\n          <option value={{opt.value}}>{{opt.label}}</option>\n        {{/each}}\n      </select>\n    </template>\n  };\n}\n```\n\n**Notes:**\n- **Reactivity**: Configuration recomputes automatically when inputs change\n- **Privacy**: Parent instance is not provided to components—only `@configuration`\n- **Types**: Configuration is intentionally opaque; field authors define shape and validate locally\n- **Loading**: If configuration function reads links, may be undefined until links load; guard template accordingly\n\n### Backward Compatibility\n\n- Existing fields continue to work with no configuration\n- Existing `contains(Field)` calls continue to work; configuration option is optional and additive\n- No template changes required\n- Editors/helpers adopt the resolver internally\n\n### Relation to enumField\n\n`enumField` can adopt the configuration mechanism by:\n\n1. Defining `static configuration?: ConfigurationInput<Parent>` that returns `{ options }`\n2. Can be POGO or function accessing links on `self` (may throw `NotLoaded`; runtime tolerates this)\n3. Parent authors can add per-usage configuration via `contains(PriorityField, { configuration })`\n4. Both sources are merged automatically\n\n## Best Practices\n\n1. **Use enumField for constrained value sets** - Provides type safety and consistent UI\n2. **Leverage rich options** - Include labels and icons for better UX\n3. **Use configuration for dynamic options** - When options depend on parent card state\n4. **Guard against loading states** - Configuration may be undefined while links load\n5. **Keep configuration shape documented** - Define clear TypeScript interfaces for field configuration\n6. **Validate against configuration** - Use merged configuration in field `validate()` methods\n7. **Use @configuration argument** - Preferred over helpers for accessing configuration in components",
      "cardInfo": {
        "notes": null,
        "title": null,
        "description": null,
        "thumbnailURL": null
      },
      "position": {
        "type": null,
        "cardInfo": {
          "notes": null,
          "title": null,
          "description": null,
          "thumbnailURL": null
        },
        "referenceId": null
      },
      "reference": "enum-field-config",
      "topicName": "Enum Fields and Field Configuration"
    },
    "relationships": {
      "cardInfo.theme": {
        "links": {
          "self": null
        }
      },
      "position.cardInfo.theme": {
        "links": {
          "self": null
        }
      }
    }
  }
}