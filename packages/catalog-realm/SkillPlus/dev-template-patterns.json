{
  "data": {
    "meta": {
      "adoptsFrom": {
        "name": "SkillPlus",
        "module": "../skill-plus"
      }
    },
    "type": "card",
    "attributes": {
      "cardInfo": {
        "notes": null,
        "title": "Template Patterns",
        "description": "Field access, delegation, arrays, and fallback patterns",
        "thumbnailURL": null
      },
      "commands": [],
      "instructions": "### Template Essentials\n\n**Field access patterns:**\n```hbs\n{{@model.title}}                    <!-- Raw data -->\n<@fields.title />                   <!-- Field's template -->\n<@fields.phone @format=\"atom\" />    <!-- Compound field -->\n<@fields.items @format=\"embedded\" /> <!-- Auto-collection -->\n```\n\nFor theming, CSS variables, spacing scales, and CSS safety rules, see Module 3: Theme-First Design System.\n\n#### ‚ö†Ô∏è CRITICAL: @model Iteration vs @fields Delegation\n\n**Once you iterate with @model, you CANNOT delegate to @fields within that iteration.**\n\n```hbs\n<!-- ‚ùå BREAKS: Mixing @model iteration with @fields delegation -->\n{{#each @model.teamMembers as |member|}}\n  <@fields.member @format=\"embedded\" />  <!-- NO ACCESS to @fields.member -->\n{{/each}}\n\n<!-- ‚úÖ OPTION 1: Use delegated rendering for the whole collection -->\n<@fields.teamMembers @format=\"embedded\" />\n\n<!-- ‚úÖ OPTION 2: Commit to full @model control -->\n{{#each @model.teamMembers as |member|}}\n  <div class=\"custom-member\">{{member.name}}</div>\n{{/each}}\n\n<!-- ‚úÖ OPTION 3: If filtering needed, use query patterns -->\n<!-- Use PrerenderedCardSearch or getCards for filtered collections -->\n```\n\n**Why this breaks:** @fields provides field-level components. Once you're iterating with @model, you're working with raw data, not field components.\n\n**Decision Rule:** Before iterating, decide:\n- Need composability? ‚Üí Use delegated rendering\n- Need filtering? ‚Üí Use query patterns (PrerenderedCardSearch/getCards)\n- Need custom control? ‚Üí Use @model but handle ALL rendering yourself\n\n### Accessing @fields by Index: The Bridge Pattern\n\n**Use Case:** You need to use `@model` data to find specific items in a `containsMany` or `linksToMany` collection, then render those items using their field templates for proper delegated rendering.\n\n**Key Concept:** The `get` helper allows you to access `@fields` array elements by index, creating a bridge between data-driven iteration and component-based rendering.\n\n#### When to Use This Pattern\n\n- **Filtering:** Show only items matching certain criteria\n- **Conditional rendering:** Display items based on model data\n- **Custom ordering:** Reorder items based on computed logic\n- **Highlighted selection:** Emphasize specific items in a collection\n\n#### Basic Pattern\n\n```hbs\n{{! Access a specific field by index }}\n{{#let (get @fields.shoppingList 0) as |firstItem|}}\n  {{#if firstItem}}\n    <firstItem @format=\"embedded\" />\n  {{else}}\n    <div class=\"no-item\">No first item</div>\n  {{/if}}\n{{/let}}\n\n{{! Access last item using subtract helper }}\n{{#let (get @fields.items (subtract @model.items.length 1)) as |lastItem|}}\n  {{#if lastItem}}\n    <lastItem @format=\"fitted\" />\n  {{/if}}\n{{/let}}\n```\n\n#### Displaying Compound Fields\n\n**CRITICAL:** When displaying compound fields (FieldDef types) like `PhoneNumberField`, `AddressField`, or custom field definitions, you must use their format templates, not raw model access:\n\n```hbs\n<!-- ‚ùå WRONG: Shows [object Object] -->\n<p>Phone: {{@model.phone}}</p>\n\n<!-- ‚úÖ CORRECT: Uses the field's atom format -->\n<p>Phone: <@fields.phone @format=\"atom\" /></p>\n\n<!-- ‚úÖ CORRECT: For full field display -->\n<div class=\"contact-info\">\n  <@fields.phone @format=\"embedded\" />\n</div>\n```\n\n**üí° Line-saving tip:** Keep self-closing tags compact:\n```hbs\n<!-- Good: Saves vertical space -->\n<@fields.author @format=\"embedded\" />\n<@fields.phone @format=\"atom\" />\n```\n\n#### @fields Delegation Rule\n\n**CRITICAL:** When delegating to embedded/fitted formats, you must iterate through `@fields`, not `@model`. Always use `@fields` for delegation, even for singular fields.\n\n```hbs\n<!-- ‚úÖ CORRECT: Using @fields for both singular and collection fields -->\n<@fields.author @format=\"embedded\" />\n<@fields.items @format=\"embedded\" />\n{{#each @fields.items as |item|}}\n  <item @format=\"embedded\" />\n{{/each}}\n\n<!-- ‚ùå WRONG: Can't iterate @model then try to delegate to @fields -->\n{{#each @model.items as |item|}}\n  <@fields.??? @format=\"embedded\" /> <!-- This won't work -->\n{{/each}}\n```\n\n**containsMany Spacing Pattern:** Due to an additional wrapper div, target `.containsMany-field`:\n```css\n/* For grids */\n.products-grid > .containsMany-field {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n  gap: 1rem;\n}\n\n/* For lists */\n.items-list > .containsMany-field {\n  display: flex;\n  flex-direction: column;\n  gap: 0.75rem;\n}\n```\n\n### Template Fallback Value Patterns\n\n**CRITICAL:** Boxel cards boot with no data by default. Templates must gracefully handle null, undefined, and empty string values at ALL levels of data access to prevent runtime errors and provide meaningful visual fallbacks.\n\n#### Three Primary Patterns for Fallbacks\n\n**1. Inline if/else (for simple display fallbacks):**\n```hbs\n<span>{{if @model.eventTime (formatDateTime @model.eventTime \"MMM D, h:mm A\") \"Event time to be announced\"}}</span>\n<h2>{{if @model.title @model.title \"Untitled Document\"}}</h2>\n<p>Status: {{if @model.status @model.status \"Status pending\"}}</p>\n```\n\n**2. Block-based if/else (for complex content):**\n```hbs\n<div class=\"event-time\">\n  {{#if @model.eventTime}}\n    <strong>{{formatDateTime @model.eventTime \"MMM D, h:mm A\"}}</strong>\n  {{else}}\n    <em class=\"placeholder\">Event time to be announced</em>\n  {{/if}}\n</div>\n\n{{#if @model.description}}\n  <div class=\"description\">\n    <@fields.description />\n  </div>\n{{else}}\n  <div class=\"empty-description\">\n    <p>No description provided yet. Click to add one.</p>\n  </div>\n{{/if}}\n```\n\n**3. Unless for safety/validation checks (composed with other helpers):**\n```hbs\n{{unless (and @model.isValid @model.hasPermission) \"‚ö†Ô∏è Cannot proceed - missing validation or permission\"}}\n{{unless (or @model.email @model.phone) \"Contact information required\"}}\n{{unless (gt @model.items.length 0) \"No items available\"}}\n{{unless (eq @model.status \"active\") \"Service unavailable\"}}\n```\n\n**Best Practices:** Use descriptive placeholder text rather than generic \"N/A\", style placeholder text differently (lighter color, italic), use `unless` for safety checks and `if` for display fallbacks.\n\n**Icon Usage:** Avoid emoji in templates (unless the application specifically calls for it) due to OS/platform variations that cause legibility issues. Use Boxel icons only for static card/field type icons (displayName properties). In templates, use inline SVG instead since we can't be sure which Boxel icons exist.\n\n### Template Array Handling Patterns\n\n**CRITICAL:** Templates must gracefully handle all array states to prevent errors. Arrays can be undefined, null, empty, or populated.\n\n#### The Three Array States\n\nYour templates must handle:\n1. **Completely undefined arrays** - Field doesn't exist or is null\n2. **Empty arrays** - Field exists but has no items (`[]`)\n3. **Arrays with actual data** - Field has one or more items\n\n#### Array Logic Pattern\n\n**‚ùå WRONG - Only checks for existence:**\n```hbs\n{{#if @model.goals}}\n  <ul class=\"goals-list\">\n    {{#each @model.goals as |goal|}}\n      <li>{{goal}}</li>\n    {{/each}}\n  </ul>\n{{/if}}\n```\n\n**‚úÖ CORRECT - Checks for length and provides empty state:**\n```hbs\n{{#if @model.goals.length}}\n  <div class=\"goals-section\">\n    <h4>\n      <svg width='16' height='16' class=\"section-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n        <circle cx=\"12\" cy=\"12\" r=\"10\"/>\n        <circle cx=\"12\" cy=\"12\" r=\"6\"/>\n        <circle cx=\"12\" cy=\"12\" r=\"2\"/>\n      </svg>\n      Daily Goals\n    </h4>\n    <ul class=\"goals-list\">\n      {{#each @model.goals as |goal|}}\n        <li>{{goal}}</li>\n      {{/each}}\n    </ul>\n  </div>\n{{else}}\n  <div class=\"goals-section\">\n    <h4>\n      <svg width='16' height='16' class=\"section-icon\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n        <circle cx=\"12\" cy=\"12\" r=\"10\"/>\n        <circle cx=\"12\" cy=\"12\" r=\"6\"/>\n        <circle cx=\"12\" cy=\"12\" r=\"2\"/>\n      </svg>\n      Daily Goals\n    </h4>\n    <p class=\"empty-state\">No goals set yet. What would you like to accomplish?</p>\n  </div>\n{{/if}}\n```\n\n**Remember:** When implementing templates via SEARCH/REPLACE, include tracking markers ‚Åø for style blocks\n\n### Real-World Example: Shopping List with Featured Items\n\n```gts\nimport { CardDef, FieldDef, field, contains, containsMany, Component } from 'https://cardstack.com/base/card-api';\nimport StringField from 'https://cardstack.com/base/string';\nimport NumberField from 'https://cardstack.com/base/number';\nimport { get } from '@ember/helper';\nimport { subtract } from '@cardstack/boxel-ui/helpers';\n\nexport class FruitItem extends FieldDef {\n  static displayName = 'Fruit';\n  @field title = contains(StringField);\n  @field quantity = contains(NumberField);\n  \n  static embedded = class Embedded extends Component<typeof this> {\n    <template>\n      <div class=\"fruit-item\">\n        <span>{{if @model.title @model.title \"Unknown\"}}</span>\n        <span>{{if @model.quantity @model.quantity 0}} units</span>\n      </div>\n    </template>\n  };\n}\n\nexport class ShoppingList extends CardDef {\n  static displayName = 'Shopping List';\n  @field items = containsMany(FruitItem);\n  \n  static isolated = class Isolated extends Component<typeof this> {\n    <template>\n      <article>\n        <h1>{{@model.title}}</h1>\n        \n        {{! Show first and last items using get helper }}\n        <section class=\"featured\">\n          <h2>First Item</h2>\n          {{#let (get @fields.items 0) as |item|}}\n            {{#if item}}\n              <item @format=\"embedded\" />\n            {{else}}\n              <p>No items</p>\n            {{/if}}\n          {{/let}}\n          \n          <h2>Last Item</h2>\n          {{#let (get @fields.items (subtract @model.items.length 1)) as |item|}}\n            {{#if item}}\n              <item @format=\"embedded\" />\n            {{/if}}\n          {{/let}}\n        </section>\n        \n        {{! Full list }}\n        <section>\n          <h2>All Items</h2>\n          {{#if @model.items.length}}\n            <@fields.items @format=\"embedded\" class=\"items-container\" />\n          {{else}}\n            <p>No items</p>\n          {{/if}}\n        </section>\n      </article>\n      \n      <style scoped>\n        .items-container {\n          gap: var(--boxel-sp-2xs);\n        }\n      </style>\n    </template>\n  };\n}\n```\n\n#### Important Notes\n\n**CRITICAL Safety Checks:**\n- Always wrap `get` results in `{{#if}}` to handle undefined indices\n- Use `subtract` helper for negative indexing (e.g., last item)\n- Validate array length before accessing by index\n\n**When NOT to Use:**\n- If you need to iterate all items ‚Üí use `<@fields.items />` delegation\n- If you need custom rendering for each ‚Üí use `{{#each @model.items}}` pattern\n- For simple filtering ‚Üí use query patterns with PrerenderedCardSearch\n\n**Performance Consideration:**\nThe `get` helper is efficient for accessing specific indices. For complex filtering or transformation, consider using query patterns or computed properties instead."
    },
    "relationships": {
      "cardInfo.theme": {
        "links": {
          "self": "../Theme/cardstack"
        }
      }
    }
  }
}