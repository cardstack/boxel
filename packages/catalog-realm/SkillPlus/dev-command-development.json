{
  "data": {
    "meta": {
      "adoptsFrom": {
        "name": "SkillPlus",
        "module": "../skill-plus"
      }
    },
    "type": "card",
    "attributes": {
      "cardInfo": {
        "notes": null,
        "title": "Command Development",
        "description": "Command structure, host APIs, and progress tracking",
        "thumbnailURL": null
      },
      "commands": [],
      "instructions": "## Command Development Essentials\n\nCommands extend `Command<InputCardDef, OutputCardDef | undefined>` and execute workflows through host APIs.\n\n### Core Structure\n\n```gts\nimport { Command } from '@cardstack/runtime-common';\nimport { CardDef, field, contains } from 'https://cardstack.com/base/card-api';\nimport StringField from 'https://cardstack.com/base/string';\n\nclass MyInput extends CardDef {\n  @field targetRealm = contains(StringField);\n}\n\nexport class MyCommand extends Command<typeof MyInput, undefined> {\n  static actionVerb = 'Process';\n  async getInputType() { return MyInput; }\n  \n  protected async run(input: MyInput): Promise<undefined> {\n    // Validation first\n    if (!input.targetRealm) throw new Error('Target realm required');\n    \n    // Execute workflow\n    // Return result or undefined\n  }\n}\n```\n\n### Host Commands (IO Operations)\n\n**Never use `fetch` directly - always use host commands:**\n\n```gts\nimport SaveCardCommand from '@cardstack/boxel-host/commands/save-card';\nimport GetCardCommand from '@cardstack/boxel-host/commands/get-card';\nimport SendRequestViaProxyCommand from '@cardstack/boxel-host/commands/send-request-via-proxy';\nimport SearchCardsByQueryCommand from '@cardstack/boxel-host/commands/search-cards-by-query';\n\n// Save a card\nawait new SaveCardCommand(this.commandContext).execute({\n  card: myCard,\n  realm: 'https://realm-url/'\n});\n\n// Get a card\nconst card = await new GetCardCommand(this.commandContext).execute({\n  cardId: 'https://realm/Card/id'\n});\n\n// External API call\nconst response = await new SendRequestViaProxyCommand(this.commandContext).execute({\n  url: 'https://api.example.com/endpoint',\n  method: 'POST',\n  requestBody: JSON.stringify(data),\n  headers: { 'Content-Type': 'application/json' }\n});\n```\n\n### OpenRouter API Pattern\n\n```gts\nconst headers = {\n  'Content-Type': 'application/json',\n  'HTTP-Referer': 'https://realms-staging.stack.cards',\n  'X-Title': 'Your App Name'\n};\n\nconst response = await new SendRequestViaProxyCommand(ctx).execute({\n  url: 'https://openrouter.ai/api/v1/chat/completions',\n  method: 'POST',\n  requestBody: JSON.stringify({\n    model: 'google/gemini-2.5-flash',\n    messages: [{ role: 'user', content: 'Your prompt' }]\n  }),\n  headers\n});\n\nif (!response.response.ok) throw new Error('API call failed');\nconst data = await response.response.json();\nconst text = data.choices?.[0]?.message?.content ?? '';\n```\n\n### Catalog Command Delegation\n\n**Reuse existing commands instead of reimplementing:**\n\n```gts\nimport UploadImageCommand from 'https://realms-staging.stack.cards/catalog/commands/upload-image';\n\nconst result = await new UploadImageCommand(this.commandContext).execute({\n  sourceImageUrl: dataUrl,\n  targetRealmUrl: input.realm\n});\n```\n\n### Query Pattern in Commands\n\n```gts\nimport SearchCardsByQueryCommand from '@cardstack/boxel-host/commands/search-cards-by-query';\n\nconst results = await new SearchCardsByQueryCommand(this.commandContext).execute({\n  query: {\n    filter: {\n      on: { module: new URL('./product', import.meta.url).href, name: 'Product' },\n      eq: { status: 'active' }\n    }\n  },\n  realmURLs: [input.realm]\n});\n```\n\n### Progress Tracking\n\n```gts\nimport { tracked } from '@glimmer/tracking';\n\nexport class MyCommand extends Command<typeof Input, undefined> {\n  @tracked step: 'idle' | 'processing' | 'completed' | 'error' = 'idle';\n  \n  protected async run(input: Input): Promise<undefined> {\n    this.step = 'processing';\n    try {\n      // Do work\n      this.step = 'completed';\n    } catch (e) {\n      this.step = 'error';\n      throw e;\n    }\n  }\n}\n```\n\n### Menu Integration\n\n```gts\nimport { getCardMenuItems } from '@cardstack/runtime-common';\n\n[getCardMenuItems](params: GetCardMenuItemParams): MenuItemOptions[] {\n  return [{\n    label: 'My Action',\n    icon: MyIcon,\n    action: async () => {\n      await new MyCommand(params.commandContext).execute({\n        cardId: this.id,\n        realm: params.realmURL\n      });\n      await params.saveCard(this);\n    }\n  }, ...super[getCardMenuItems](params)];\n}\n```\n\n### Critical Rules\n\n- ✅ **Validate inputs first** - fail early with clear errors\n- ✅ **Use host commands for all IO** - never `fetch` directly\n- ✅ **Include `on` in queries** - for eq/contains/range filters\n- ✅ **Delegate to catalog commands** - don't reimplement uploads/services\n- ✅ **Wrap JSON parsing in try-catch** - handle malformed responses\n- ✅ **Track progress states** - use `@tracked` for UI feedback"
    },
    "relationships": {
      "cardInfo.theme": {
        "links": {
          "self": "../Theme/cardstack"
        }
      }
    }
  }
}