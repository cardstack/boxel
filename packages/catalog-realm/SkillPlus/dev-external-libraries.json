{
  "data": {
    "meta": {
      "adoptsFrom": {
        "name": "SkillPlus",
        "module": "../skill-plus"
      }
    },
    "type": "card",
    "attributes": {
      "cardInfo": {
        "notes": null,
        "title": "External Libraries",
        "description": "Async loading patterns and third-party integration",
        "thumbnailURL": null
      },
      "commands": [],
      "instructions": "**Async loading pattern:**\n```gts\nimport { task, restartableTask, timeout } from 'ember-concurrency';\nimport Modifier from 'ember-modifier';\n\nprivate loadLibrary = task(async () => {\n  const script = document.createElement('script');\n  script.src = 'https://cdn.../library.js';\n  await new Promise((resolve, reject) => {\n    script.onload = resolve;\n    script.onerror = reject;\n    document.head.appendChild(script);\n  });\n});\n```\n\n**Key Rules:**\n1. Use Modifiers for DOM access\n2. Use ember-concurrency tasks for async\n3. Bind external data to model fields\n4. Provide loading states\n\n**Task types:**\n- `task` - Concurrent execution\n- `restartableTask` - Cancel previous, start new\n- `enqueueTask` - Sequential queue\n- `dropTask` - Ignore new while running\n\n## Async loading from within components\n\nFor fetching data from external APIs, use `ember-concurrency`. The core of this principle are \"tasks\", which are a cancelable alternative to promises. The most used ones are `task`, and `restartableTask`:\n\n- task: Tasks run concurrently without any coordination, allowing multiple instances to execute simultaneously.\n- restartableTask: Cancels any running task and immediately starts a new one when performed, ensuring only the latest task runs.\n- enqueueTask: Queues tasks to run sequentially one after another, ensuring no overlap but preserving all tasks.\n- dropTask: Ignores new task requests while one is already running, preventing any additional instances from starting.\n- keepLatest: Drops intermediate queued tasks but keeps the most recent one to run after the current task completes.\n\nHere is an example where we are:\n- loading data when component is first rendered, \n- reloading it when user clicks on a button,\n- adding some artificial delay using `await timeout(ms)` from `ember-concurrency`. Caution:  do not use `setTimeout`.\n\n```\nimport { CardDef, field, contains, Component } from 'https://cardstack.com/base/card-api';\nimport StringField from 'https://cardstack.com/base/string';\nimport { tracked } from '@glimmer/tracking';\nimport { restartableTask, timeout } from 'ember-concurrency';\nimport { Button } from '@cardstack/boxel-ui/components';\nimport { on } from '@ember/modifier';\nimport perform from 'ember-concurrency/helpers/perform';\n\nexport class CurrencyLoader extends CardDef {\n  static displayName = 'Currency Loader';\n  \n  @field loadingStatus = contains(StringField);\n  @field currencies = contains(StringField);\n  \n  static isolated = class Isolated extends Component<typeof this> {\n    constructor(owner: any, args: any) {\n      super(owner, args);\n      this.loadCurrencies.perform();\n    }\n    \n    private loadCurrencies = restartableTask(async () => {\n      this.args.model.loadingStatus = 'Loading...';\n      const response = await fetch('/api/currencies');\n      await timeout(1000); // Visual feedback\n      \n      this.args.model.currencies = await response.json();\n      this.args.model.loadingStatus = \"\";\n    });\n    \n    <template>\n      <div>\n        <p>Status: {{@model.loadingStatus}}</p>\n        <p>Data: {{@model.currencies}}</p>\n        \n        <Button {{on 'click' (perform this.loadCurrencies)}}>\n          Reload Currencies\n        </Button>\n      </div>\n    </template>\n  };\n}\n```\n\n## External Libraries: Bringing Third-Party Power to Boxel\n\n**When to Use External Libraries:** Sometimes you need specialized functionality like 3D graphics (Three.js), data visualization (D3), or charts. Boxel plays well with external libraries when you follow the right patterns.\n\n**Key Rules:**\n1. **Always use Modifiers for DOM access** - Never manipulate DOM directly\n2. **Use ember-concurrency tasks** for async operations like loading libraries\n3. **Bind external data to model fields** for reactive updates\n4. **Use proper loading states** while libraries initialize"
    },
    "relationships": {
      "cardInfo.theme": {
        "links": {
          "self": "../Theme/cardstack"
        }
      }
    }
  }
}