{
  "data": {
    "meta": {
      "adoptsFrom": {
        "name": "Skill",
        "module": "https://cardstack.com/base/skill"
      }
    },
    "type": "card",
    "attributes": {
      "title": "Query Systems",
      "cardInfo": {
        "notes": null,
        "title": null,
        "description": null,
        "thumbnailURL": null
      },
      "commands": [],
      "description": "Finding and displaying cards with PrerenderedCardSearch and getCards",
      "instructions": "## Query Essentials\n\n**The 'on' Rule (MEMORIZE THIS!):**\n```ts\n// ❌ WRONG - Missing 'on'\n{ range: { price: { lte: 100 } } }\n\n// ✅ CORRECT - Include 'on' for filters\n{\n  on: { module: new URL('./product', import.meta.url).href, name: 'Product' },\n  range: { price: { lte: 100 } }\n}\n```\n\n**Filter types needing 'on':**\n- `eq`, `contains`, `range` (except after type filter)\n- Sort on type-specific fields\n\n**Basic query pattern:**\n```ts\nconst query = {\n  filter: {\n    every: [\n      { type: { module: '...', name: 'Product' } },\n      { on: { module: '...', name: 'Product' }, eq: { status: 'active' } }\n    ]\n  }\n};\n```\n\n**When to use what:**\n- Display cards as-is → `PrerenderedCardSearch`\n- Need data manipulation → `getCards`\n\n<!--more-->\n\n# Query System\n\n## The 'on' Property Rule\n\n**CRITICAL:** When using filters beyond basic type search, MUST include `on` as sibling.\n\n```typescript\n// ❌ WRONG\n{ range: { price: { lte: 100 } } }\n\n// ✅ CORRECT\n{ \n  on: { module: new URL('./product', import.meta.url).href, name: 'Product' },\n  range: { price: { lte: 100 } } \n}\n```\n\n## Filter Types\n\n| Filter | Needs 'on'? | Example |\n|--------|-------------|----------|\n| `type` | No | `{ type: { module: '...', name: 'Product' } }` |\n| `eq` | Yes* | `{ on: {...}, eq: { status: \"active\" } }` |\n| `contains` | Yes | `{ on: {...}, contains: { tags: \"urgent\" } }` |\n| `range` | Yes | `{ on: {...}, range: { price: { gte: 100 } } }` |\n| `every` | No | `{ every: [...] }` (AND) |\n| `any` | No | `{ any: [...] }` (OR) |\n\n*Not needed immediately after type filter\n\n## PrerenderedCardSearch Pattern\n\n```gts\nget urgentTasksQuery(): Query {\n  return {\n    filter: {\n      every: [\n        { type: { module: new URL('./task', import.meta.url).href, name: 'Task' } },\n        { \n          on: { module: new URL('./task', import.meta.url).href, name: 'Task' },\n          not: { eq: { status: \"completed\" } }\n        }\n      ]\n    },\n    sort: [{ by: \"dueDate\", direction: \"asc\" }]\n  };\n}\n\nrealms = ['https://app.boxel.ai/sarah/tasks/'];\n\n<template>\n  {{#let (component @context.prerenderedCardSearchComponent) as |PrerenderedCardSearch|}}\n    <PrerenderedCardSearch\n      @query={{this.urgentTasksQuery}}\n      @format=\"embedded\"\n      @realms={{this.realms}}\n      @isLive={{true}}\n    >\n      <:response as |cards|>\n        {{#each cards as |card|}}\n          <card.component />\n        {{/each}}\n      </:response>\n    </PrerenderedCardSearch>\n  {{/let}}\n</template>\n```\n\n## getCards Pattern\n\n```gts\ncardsResult = this.args.context?.getCards(\n  this,\n  () => this.query,\n  () => this.realms,\n  { isLive: true }\n);\n\nget sortedCards() {\n  const cards = this.cardsResult?.instances ?? [];\n  return [...cards].sort((a, b) => b.rating - a.rating);\n}\n```\n\n## Decision Tree\n\n```\nDisplay cards as-is? → PrerenderedCardSearch\nNeed live updates? → PrerenderedCardSearch with @isLive={{true}}\nNeed to sort/filter AFTER retrieval? → getCards\nNeed raw data access? → getCards\n```"
    },
    "relationships": {
      "cardInfo.theme": {
        "links": {
          "self": null
        }
      }
    }
  }
}