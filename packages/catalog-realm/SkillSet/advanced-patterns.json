{
  "data": {
    "meta": {
      "adoptsFrom": {
        "name": "Skill",
        "module": "https://cardstack.com/base/skill"
      }
    },
    "type": "card",
    "attributes": {
      "title": "Delegated Rendering",
      "cardInfo": {
        "notes": null,
        "title": "Delegated Rendering",
        "description": null,
        "thumbnailURL": null
      },
      "commands": [],
      "description": "Delegated rendering, BoxelSelect, CardContainer, avoiding relationship cycles, and viewCard API",
      "instructions": "**Delegated rendering:**\n```hbs\n<!-- Always use @fields, even for singular -->\n<@fields.author @format=\"embedded\" />\n<@fields.items @format=\"embedded\" />\n```\n\n**Make cards clickable:**\n```hbs\n<CardContainer\n  {{@context.cardComponentModifier\n    cardId=card.url\n    format='data'\n  }}\n  @displayBoundaries={{true}}\n>\n  <card.component />\n</CardContainer>\n```\n\n**Avoid cycles:**\n```gts\n// Canonical links only\n@field supervisor = linksTo(() => Employee);\n\n// Query for reverse\nget directReportsQuery() {\n  return {\n    filter: {\n      on: { module: './employee', name: 'Employee' },\n      eq: { supervisor: this.args.model.id }\n    }\n  };\n}\n```\n\n<!--more-->\n\n## Advanced Patterns\n\n### Delegated Rendering: Making Cards Talk To Each Other\n\n**What is Delegated Rendering?** Boxel's superpower that lets you embed one card inside another while preserving each card's own styling and behavior. Creates truly composable interfaces where each component maintains its identity while seamlessly integrating into larger contexts.\n\n**CRITICAL:** Always use `<@fields.entity />` for delegation, even for singular fields (not `<@field.entity />`).\n\n**DESIGN CONSISTENCY:** When delegating from a custom-designed template, ensure the delegated card/field's format has matching design aesthetics. Mismatched styles create jarring user experiences.\n\n```gts\n// ³⁹ If your parent card has a modern, minimal design with specific colors/fonts...\nstatic isolated = class Isolated extends Component<typeof this> {\n  <template>\n    <div class=\"modern-container\">\n      <!-- The author card's embedded format should match this aesthetic -->\n      <@fields.author @format=\"embedded\" />\n    </div>\n    <style scoped>\n      .modern-container {\n        font-family: 'Inter', sans-serif;\n        background: #f8fafc;\n        border-radius: 12px;\n      }\n    </style>\n  </template>\n};\n\n// ⁴⁰ Then the Author card should have complementary styling:\nexport class Author extends CardDef {\n  static embedded = class Embedded extends Component<typeof this> {\n    <template>\n      <div class=\"author-card\">\n        <!-- Matching the parent's design language -->\n      </div>\n      <style scoped>\n        .author-card {\n          font-family: 'Inter', sans-serif;  /* Same font */\n          background: white;                  /* Complementary color */\n          border-radius: 8px;                 /* Consistent radius style */\n        }\n      </style>\n    </template>\n  };\n}\n```\n\n#### Delegation Patterns\n\n```gts\n<template>\n  <!-- ⁴¹ Single card rendering - still use @fields -->\n  <div class=\"author-section\">\n    {{#if @fields.author}}\n      <@fields.author />\n    {{else}}\n      <div class=\"author-placeholder\">No author assigned</div>\n    {{/if}}\n  </div>\n  \n  <!-- ⁴² Collection with REQUIRED custom spacing -->\n  {{#if (gt @model.relatedPosts.length 0)}}\n    <div class=\"posts-container\">\n      <@fields.relatedPosts @format=\"embedded\" />\n    </div>\n  {{/if}}\n  \n  <style scoped>\n    /* Target .containsMany-field due to wrapper div */\n    .posts-container > .containsMany-field {\n      display: flex;\n      flex-direction: column;\n      gap: 0.75rem;  /* REQUIRED: Spacing between items */\n    }\n  </style>\n</template>\n```\n\n### Avoiding Relationship Cycles\n\n**Problem:** Bidirectional `linksTo` relationships create circular dependencies that complicate indexing and can cause infinite recursion.\n\n**Solution:** Use canonical (one-way) links + dynamic queries for reverse relationships.\n\n#### Pattern: Canonical Links + Dynamic Queries\n\n1. **Define canonical links** - Choose the primary direction in your schema:\n```gts\n// Employee owns the supervisor relationship\nexport class Employee extends CardDef {\n  @field supervisor = linksTo(() => Employee);\n  @field department = linksTo(Department);\n}\n\n// Department owns the manager relationship\nexport class Department extends CardDef {\n  @field manager = linksTo(Employee);\n}\n```\n\n2. **Use dynamic queries for reverse relationships** - Fetch at runtime instead of schema links:\n```gts\n// Get direct reports dynamically (in Employee component)\nget directReportsQuery(): Query {\n  return {\n    filter: {\n      on: { module: './employee', name: 'Employee' },\n      eq: { supervisor: this.args.model.id }\n    }\n  };\n}\n\n// Use with getCards or PrerenderedCardSearch\ndirectReports = this.args.context?.getCards(this, () => this.directReportsQuery, () => this.realms);\n```\n\n**Key Principle:** Model the simplest set of unidirectional links that define core relationships. Use queries for derived views, aggregations, and inverse relationships.\n\n### BoxelSelect: Smart Dropdown Menus\n\nRegular HTML selects are limited to plain text. BoxelSelect lets you create rich, searchable dropdowns with custom rendering.\n\n#### Pattern: Rich Select with Custom Options\n\n```gts\nexport class OptionField extends FieldDef { // ⁴³ Option field for select\n  static displayName = 'Option';\n  \n  @field key = contains(StringField);\n  @field label = contains(StringField);\n  @field description = contains(StringField);\n\n  static embedded = class Embedded extends Component<typeof this> {\n    <template>\n      <div class=\"option-display\">\n        <strong>{{if @model.label @model.label \"Unnamed Option\"}}</strong>\n        <span>{{if @model.description @model.description \"No description\"}}</span>\n      </div>\n    </template>\n  };\n}\n\nexport class ProductCategory extends CardDef { // ⁴⁴ Card using BoxelSelect\n  @field selectedCategory = contains(OptionField);\n  \n  static edit = class Edit extends Component<typeof this> { // ⁴⁵ Edit format\n    @tracked selectedOption = this.args.model?.selectedCategory;\n\n    options = [\n      { key: '1', label: 'Electronics', description: 'Phones, computers, and gadgets' },\n      { key: '2', label: 'Clothing', description: 'Fashion and apparel' },\n      { key: '3', label: 'Home & Garden', description: 'Furniture and decor' }\n    ];\n\n    updateSelection = (option: typeof this.options[0] | null) => {\n      this.selectedOption = option;\n      this.args.model.selectedCategory = option ? new OptionField(option) : null;\n    }\n\n    <template>\n      <FieldContainer @label=\"Product Category\">\n        <BoxelSelect\n          @selected={{this.selectedOption}}\n          @options={{this.options}}\n          @onChange={{this.updateSelection}}\n          @searchEnabled={{true}}\n          @placeholder=\"Select a category...\"\n          as |option|\n        >\n          <div class=\"option-item\">\n            <span>{{option.label}}</span>\n            <span>{{option.description}}</span>\n          </div>\n        </BoxelSelect>\n      </FieldContainer>\n    </template>\n  };\n}\n```\n\n### Custom Edit Controls\n\nCreate user-friendly edit controls that accept natural input. Hide complexity in expandable sections while keeping ALL properties editable and inspectable.\n\n```gts\n// Example: Natural language time period input\nstatic edit = class Edit extends Component<typeof this> {\n  @tracked showDetails = false;\n  \n  parseInput = (value: string) =>{\n    // Parse \"Q1 2025\" → quarter: 1, year: 2025, startDate: Jan 1, endDate: Mar 31\n    // Parse \"April 2025\" → month: 4, year: 2025, startDate: Apr 1, endDate: Apr 30\n  }\n  \n  <template>\n    <FieldContainer @label=\"Time Period\">\n      <input placeholder=\"e.g., Q1 2025 or April 2025\" {{on 'blur' this.parseInput}} />\n    </FieldContainer>\n    \n    <Button {{on 'click' (toggle 'showDetails' this)}}>\n      {{if this.showDetails \"Hide\" \"Show\"}} Details\n    </Button>\n    \n    {{#if this.showDetails}}\n      <!-- Show all parsed values for verification -->\n      <!-- Allow manual override of auto-parsed results -->\n      <!-- Provide controls for each field property -->\n    {{/if}}\n  </template>\n};\n```\n\n### CardContainer: Making Cards Clickable\n\nTransforms cards into interactive, clickable elements for viewing or editing, complete with visual chrome. When used with the `cardComponentModifier`, it enables users to click through to view or edit the wrapped card.\n\n#### Usage\n\n```gts\n<template>\n  {{#if (gt @model.members.length 0)}}\n    <div class=\"members-grid\">\n      {{#each @fields.members as |member|}}\n        <CardContainer   \n            {{@context.cardComponentModifier\n            cardId=member.url\n            format='data'\n            fieldCategories=undefined\n            fieldName=undefined\n            }}\n            @displayBoundaries={{true}}>\n          <member @format=\"fitted\" />\n        </CardContainer>\n      {{/each}}\n    </div>\n  {{/if}}\n  \n  <style scoped>\n    .members-grid {\n      display: grid;\n      grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));\n      gap: 12px;\n    }\n    \n    /* If using containsMany delegation instead of manual iteration */\n    .members-container > .containsMany-field {\n      display: grid;\n      grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));\n      gap: 12px;\n    }\n  </style>\n</template>\n```\n\n**CRITICAL: Style Boxel UI Components for Custom Templates**\n\n**Boxel UI components (Button, BoxelSelect, etc.) must be completely styled when used in custom isolated, embedded, and fitted templates.** They come with minimal default styling and buttons especially will look broken without custom CSS.\n\n```gts\n<template>\n  <!-- ⁴⁶ NEVER use unstyled buttons - always add complete custom styling -->\n  <Button \n    @variant=\"primary\"\n    class=\"save-button\"\n    {{on 'click' this.handleSave}}\n  >\n    Save Changes\n  </Button>\n  \n  <style scoped> /* ⁴⁷ Required button styles */\n    /* CRITICAL: Always style buttons completely - default styling is insufficient */\n    .save-button {\n      /* Style Boxel components to match your design */\n      padding: 0.375rem 0.75rem;\n      font-size: 0.8125rem;\n      display: inline-flex;\n      align-items: center;\n      gap: 0.25rem;\n    }\n  </style>\n</template>\n```\n### Alternative: Using the viewCard API\n\nInstead of making entire cards clickable, you can create custom buttons or links that use the `viewCard` API to open cards in specific formats.\n\n#### Basic Implementation\n\n```javascript\nviewOrder = (order: ProductOrder) => {\n  // Open order in isolated view\n  this.args.viewCard(order, 'isolated');\n};\n\neditOrder = (order: ProductOrder) => {\n  // Open card in rightmost stack for side-by-side reference\n  // Useful for: 1) reference lookup, 2) edit panel on right while previewing on left\n    this.args.viewCard(order, 'edit',  {\n    openCardInRightMostStack: true\n  });\n};\n\nviewReturnPolicy = () => {\n  // Open card using URL\n  const returnPolicyURL = new URL('https://app.boxel.ai/markinc/storefront/ReturnPolicy/return-policy-0525.json');\n  this.args.viewCard(returnPolicyURL, 'isolated');\n};\n```\n\n#### Template Example\n\n```hbs\n<div class=\"order-card\">\n  <!-- Custom action buttons -->\n  <div class=\"order-actions\">\n    <BoxelButton @kind=\"primary\" {{on \"click\" (fn this.viewOrder order)}}>\n      View Order\n    </Button>\n    \n    <BoxelButton @kind=\"secondary-light\" {{on \"click\" (fn this.editOrder order)}}>\n      Edit Order\n    </Button>\n  </div>\n  \n\n  <BoxelButton @kind=\"text-only\" {{on \"click\" (fn this.viewReturnPolicy)}}>\n      Return Policy\n  </Button>\n</div>\n```\n\n#### Available Formats\n\n- `'isolated'` - Read-oriented mode, may have some editable forms or interactive widgets\n- `'edit'` - Open card for full editing\n\n#### Use Cases\n- Multiple direct call-to-actions per card (view, edit)\n- More control over user interactions\n- Link to any card via a card URL"
    },
    "relationships": {
      "cardInfo.theme": {
        "links": {
          "self": null
        }
      }
    }
  }
}