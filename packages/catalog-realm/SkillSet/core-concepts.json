{
  "data": {
    "meta": {
      "adoptsFrom": {
        "name": "Skill",
        "module": "https://cardstack.com/base/skill"
      }
    },
    "type": "card",
    "attributes": {
      "title": "Core Concept",
      "cardInfo": {
        "notes": null,
        "title": null,
        "description": null,
        "thumbnailURL": null
      },
      "commands": [],
      "description": "Foundational Boxel concepts: CardDef, FieldDef, formats, and the Boxel universe",
      "instructions": "## Foundation Quick Reference\n\n**Data Structure Choice:**\n- Needs own identity? â†’ `CardDef` with `linksTo`\n- Referenced from multiple places? â†’ `CardDef` with `linksTo`\n- Just compound data? â†’ `FieldDef` with `contains`\n\n**Formats (what they are):**\n- `isolated` - Full detailed view (scrollable)\n- `embedded` - Compact for inclusion in other cards\n- `fitted` - Fixed dimensions for grids/galleries\n- `atom` - Minimal inline representation\n- `edit` - Form for data modification\n\n**Every CardDef inherits:**\n- `title`, `description`, `thumbnailURL`\n\n<!--more-->\n\n# Core Concepts\n\n## The Boxel Universe\n\nBoxel is a composable card-based system where information lives in self-contained, reusable units. Each card knows how to display itself, connect to others, and transform its appearance based on context.\n\n* **Card:** The central unit of information and display\n  * **Definition (`CardDef` in `.gts`):** Defines the structure (fields) and presentation (templates) of a card type\n  * **Instance (`.json`):** Represents specific data conforming to a Card Definition\n\n* **Field:** Building blocks within a Card\n  * **Base Types:** System-provided fields (StringField, NumberField, etc.)\n  * **Custom Fields (`FieldDef`):** Reusable composite field types you define\n\n* **Realm/Workspace:** Your project's root directory. All imports and paths are relative to this context\n\n* **Formats:** Different visual representations of the same card:\n  * `isolated`: Full detailed view (should be scrollable for long content)\n  * `embedded`: Compact view for inclusion in other cards\n  * `fitted`: **ðŸš¨ ESSENTIAL** - Fixed dimensions for grids/galleries/dashboards (parent sets both width AND height)\n  * `atom`: Minimal inline representation\n  * `edit`: Form for data modification (default provided, override only if needed)\n\n**ðŸ”´ CRITICAL:** Modern Boxel cards require ALL THREE display formats: isolated, embedded, AND fitted. Missing custom fitted format will fallback to basic fitted view that won't look very nice or have enough info to show in grids, choosers, galleries, or dashboards.\n\n### Base Card Fields\n\n**IMPORTANT:** Every CardDef automatically inherits these base fields:\n- `title` (StringField) - Used for card headers and tiles\n- `description` (StringField) - Used for card summaries\n- `thumbnailURL` (StringField) - Used for card preview images\n- `info` (reserved) - Future use\n\n**âœ… You CAN override these inherited fields with computed versions:**\n```gts\n// âœ… CORRECT - Override inherited title with computed version\n// â•â•â• [EDIT TRACKING: ON] Mark all changes with â¿ â•â•â•\nexport class BlogPost extends CardDef {\n  @field headline = contains(StringField); // Your primary field\n  \n  // Override parent's title with computed version\n  @field title = contains(StringField, {\n    computeVia: function() { return this.headline ?? 'Untitled'; }\n  });\n}\n```\n\n**âŒ You CANNOT define the same field twice in your own class:**\n```gts\n// âŒ WRONG - Defining same field name twice\nexport class BlogPost extends CardDef {\n  @field title = contains(StringField);\n  @field title = contains(StringField, { computeVia: ... }); // ERROR!\n}\n```\n\n**Best Practice:** Define your own primary identifier field (e.g., `name`, `headline`, `productName`) and compute the inherited `title` from it:\n\n```gts\nexport class Product extends CardDef { // Â¹Â² Card definition\n  @field productName = contains(StringField); // Â¹Â³ Primary field - NOT 'title'!\n  @field price = contains(NumberField);\n  \n  // Â¹â´ Compute the inherited title from your primary field\n  @field title = contains(StringField, {\n    computeVia: function(this: Product) {\n      const name = this.productName ?? 'Unnamed Product';\n      const price = this.price ? ` - ${this.price}` : '';\n      return `${name}${price}`;\n    }\n  });\n}\n```\n\n**âš ï¸ CRITICAL: Keep computed titles simple and unidirectional**\n- Only reference OTHER fields, never self-reference\n- Don't create circular dependencies between computed fields\n- Keep logic simple - just format/combine existing field values\n- If complex logic is needed, compute from base fields only\n\n**Remember:** When implementing via SEARCH/REPLACE, include tracking markers â¿\n\n## Decision Trees\n\n**Data Structure Choice:**\n```\nNeeds own identity? â†’ CardDef with linksTo\nReferenced from multiple places? â†’ CardDef with linksTo  \nJust compound data? â†’ FieldDef with contains\n```\n\n**Field Extension Choice:**\n```\nWant to customize a base field? â†’ import BaseField, extend it\nCreating new field type? â†’ extends FieldDef directly\nAdding to existing field? â†’ extends BaseFieldName\n```\n\n**Value Setup:**\n```\nComputed from other fields? â†’ computeVia\nUser-editable with default? â†’ Field literal or computeVia\nSimple one-time value? â†’ Field literal\n```\n\n**Circular Dependencies?**\n```\nUse arrow function: () => Type\n```\n\n## Quick Mental Check Before Every Field\n\nAsk yourself: \"Does this type extend CardDef or FieldDef?\"\n- Extends **CardDef** â†’ MUST use `linksTo` or `linksToMany`\n- Extends **FieldDef** â†’ MUST use `contains` or `containsMany`\n- **No exceptions!**\n\nFor computed fields, ask: \"Am I keeping this simple and unidirectional?\"\n- Only reference base fields, never self-reference\n- No circular dependencies between computed fields\n- Wrap in try-catch when accessing relationships\n- If it feels complex, simplify it!\n\n## Format Dimensions Comparison\n\n| Format | Width | Height | Parent Sets | Key Behavior |\n|--------|-------|--------|-------------|-------------|\n| **Isolated** | Max-width + centered | Natural + scrollable | âŒ Neither | Full viewport available |\n| **Embedded** | Fills container | Natural (parent can limit) | âœ… Width only | Parent can add \"view more\" controls |\n| **Fitted** | Fills exactly | Fills exactly | âœ… **Both** | Fills available width AND height |\n| **Atom** | Inline/shrink to fit | Inline | âŒ Neither | Self-contained sizing |\n| **Edit** | Fills container | Natural form height | âœ… Width only | Grows with fields |\n\n### Embedded Height Control Pattern\n```css\n/* Parent can limit embedded height with expand control */\n.embedded-container {\n  max-height: 200px;\n  overflow: hidden;\n  position: relative;\n}\n\n.embedded-container.expanded {\n  max-height: none;\n}\n```\n\n### Fitted Grid Gallery Pattern\n```css\n/* Parent must set both dimensions for fitted format */\n.photo-gallery > .containsMany-field {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));\n  grid-auto-rows: 300px;  /* Fixed height required for fitted */\n  gap: 1rem;\n}\n```\n\n### Quick Rule: Embedded vs Fitted\n**Embedded:** Like paragraphs - flow naturally, parent can truncate  \n**Fitted:** Like photos - exact dimensions required"
    },
    "relationships": {
      "cardInfo.theme": {
        "links": {
          "self": null
        }
      }
    }
  }
}