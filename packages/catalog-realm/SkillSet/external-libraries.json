{
  "data": {
    "meta": {
      "adoptsFrom": {
        "name": "Skill",
        "module": "https://cardstack.com/base/skill"
      }
    },
    "type": "card",
    "attributes": {
      "title": "External Libraries",
      "cardInfo": {
        "notes": null,
        "title": "External Libraries",
        "description": null,
        "thumbnailURL": null
      },
      "commands": [],
      "description": "Integrating third-party libraries, async loading with ember-concurrency, and DOM access patterns",
      "instructions": "**Async loading pattern:**\n```gts\nimport { task, restartableTask, timeout } from 'ember-concurrency';\nimport Modifier from 'ember-modifier';\n\nprivate loadLibrary = task(async () => {\n  const script = document.createElement('script');\n  script.src = 'https://cdn.../library.js';\n  await new Promise((resolve, reject) => {\n    script.onload = resolve;\n    script.onerror = reject;\n    document.head.appendChild(script);\n  });\n});\n```\n\n**Key Rules:**\n1. Use Modifiers for DOM access\n2. Use ember-concurrency tasks for async\n3. Bind external data to model fields\n4. Provide loading states\n\n**Task types:**\n- `task` - Concurrent execution\n- `restartableTask` - Cancel previous, start new\n- `enqueueTask` - Sequential queue\n- `dropTask` - Ignore new while running\n\n<!--more-->\n\n## Async loading from within components\n\nFor fetching data from external APIs, use `ember-concurrency`. The core of this principle are \"tasks\", which are a cancelable alternative to promises. The most used ones are `task`, and `restartableTask`:\n\n- task: Tasks run concurrently without any coordination, allowing multiple instances to execute simultaneously.\n- restartableTask: Cancels any running task and immediately starts a new one when performed, ensuring only the latest task runs.\n- enqueueTask: Queues tasks to run sequentially one after another, ensuring no overlap but preserving all tasks.\n- dropTask: Ignores new task requests while one is already running, preventing any additional instances from starting.\n- keepLatest: Drops intermediate queued tasks but keeps the most recent one to run after the current task completes.\n\nHere is an example where we are:\n- loading data when component is first rendered, \n- reloading it when user clicks on a button,\n- adding some artificial delay using `await timeout(ms)` from `ember-concurrency`. Caution:  do not use `setTimeout`.\n\n```\nimport { CardDef, field, contains, Component } from 'https://cardstack.com/base/card-api';\nimport StringField from 'https://cardstack.com/base/string';\nimport { tracked } from '@glimmer/tracking';\nimport { restartableTask, timeout } from 'ember-concurrency';\nimport { Button } from '@cardstack/boxel-ui/components';\nimport { on } from '@ember/modifier';\nimport perform from 'ember-concurrency/helpers/perform';\n\nexport class CurrencyLoader extends CardDef {\n  static displayName = 'Currency Loader';\n  \n  @field loadingStatus = contains(StringField);\n  @field currencies = contains(StringField);\n  \n  static isolated = class Isolated extends Component<typeof this> {\n    constructor(owner: any, args: any) {\n      super(owner, args);\n      this.loadCurrencies.perform();\n    }\n    \n    private loadCurrencies = restartableTask(async () => {\n      this.args.model.loadingStatus = 'Loading...';\n      const response = await fetch('/api/currencies');\n      await timeout(1000); // Visual feedback\n      \n      this.args.model.currencies = await response.json();\n      this.args.model.loadingStatus = \"\";\n    });\n    \n    <template>\n      <div>\n        <p>Status: {{@model.loadingStatus}}</p>\n        <p>Data: {{@model.currencies}}</p>\n        \n        <Button {{on 'click' (perform this.loadCurrencies)}}>\n          Reload Currencies\n        </Button>\n      </div>\n    </template>\n  };\n}\n```\n\n## External Libraries: Bringing Third-Party Power to Boxel\n\n**When to Use External Libraries:** Sometimes you need specialized functionality like 3D graphics (Three.js), data visualization (D3), or charts. Boxel plays well with external libraries when you follow the right patterns.\n\n**Key Rules:**\n1. **Always use Modifiers for DOM access** - Never manipulate DOM directly\n2. **Use ember-concurrency tasks** for async operations like loading libraries\n3. **Bind external data to model fields** for reactive updates\n4. **Use proper loading states** while libraries initialize\n\n### Pattern: Dynamic Three.js Integration\n\n```gts\nimport { task } from 'ember-concurrency';\nimport Modifier from 'ember-modifier';\n\n// Global accessor function\nfunction three() {\n  return (globalThis as any).THREE;\n}\n\nclass ThreeJsComponent extends Component<typeof ThreeJsCard> {\n  @tracked errorMessage = '';\n  private canvasElement: HTMLCanvasElement | undefined;\n  \n  private loadThreeJs = task(async () => {\n    if (three()) return;\n    \n    const script = document.createElement('script');\n    script.src = 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js';\n    script.async = true;\n    \n    await new Promise((resolve, reject) => {\n      script.onload = resolve;\n      script.onerror = reject;\n      document.head.appendChild(script);\n    });\n  });\n\n  private initThreeJs = task(async () => {\n    try {\n      await this.loadThreeJs.perform();\n      if (!three() || !this.canvasElement) return;\n      \n      const THREE = three();\n      \n      // Scene setup - bind results to model fields for reactivity\n      this.scene = new THREE.Scene();\n      // ... setup scene\n      \n      // CRITICAL: Bind external data to model fields\n      this.args.model.sceneReady = true;\n      this.args.model.lastUpdated = new Date();\n      \n      this.animate();\n    } catch (e: any) {\n      this.errorMessage = `Error: ${e.message}`;\n    }\n  });\n\n  private onCanvasElement = (element: HTMLCanvasElement) => {\n    this.canvasElement = element;\n    this.initThreeJs.perform();\n  };\n\n  <template>\n    {{#if this.initThreeJs.isRunning}}\n      <div class=\"loading\">Initializing 3D scene...</div>\n    {{/if}}\n    \n    <canvas {{CanvasModifier onElement=this.onCanvasElement}}></canvas>\n  </template>\n}\n```"
    },
    "relationships": {
      "cardInfo.theme": {
        "links": {
          "self": null
        }
      }
    }
  }
}