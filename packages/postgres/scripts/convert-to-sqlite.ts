/* eslint-env node */
import { readFileSync, readdirSync, writeFileSync } from 'fs-extra';
import { resolve, join } from 'path';
import {
  parse,
  type CreateTableStmt,
  type AlterTableStmt,
  type Program,
} from 'sql-parser-cst';

// Currently this script only cares about CREATE TABLE statements and ALTER
// TABLE statements that add primary key constraints. All the other schema aspects of the
// pg_dump are generally beyond the capability of SQLite. Perhaps index creation
// can be added but it will get really tricky fast since SQLite's indices are
// much more simplistic than postgres.

const args = process.argv;
const migrationsDir = resolve(join(__dirname, '..', 'migrations'));
const sqliteSchemaDir = resolve(
  join(__dirname, '..', '..', 'host', 'config', 'schema'),
);
const INDENT = '  ';

let pgDumpFile = args[2];
if (!pgDumpFile) {
  console.error(`please specify the path of the pg_dump file`);
  process.exit(-1);
}
let pgDump = readFileSync(pgDumpFile, 'utf8');

let cst = parse(prepareDump(pgDump), {
  dialect: 'postgresql',
});

let sql: string[] = [
  `
-- This is auto-generated by packages/realm-server/scripts/convert-to-sqlite.ts
-- Please don't directly modify this file

`,
];
for (let statement of cst.statements) {
  if (statement.type !== 'create_table_stmt') {
    continue;
  }
  sql.push('CREATE TABLE IF NOT EXISTS');
  if (
    statement.name.type === 'member_expr' &&
    statement.name.property.type === 'identifier'
  ) {
    let tableName = statement.name.property.name;
    sql.push(statement.name.property.name, '(\n');
    createColumns(cst, tableName, statement, sql);
  } else {
    throw new Error(`could not determine table name to be created`);
  }

  sql.push('\n);\n\n');
}

let result = sql.join(' ').trim();
let filename = getSchemaFilename();
let schemaFile = join(sqliteSchemaDir, filename);
writeFileSync(schemaFile, result);
console.log(`created SQLite schema file ${schemaFile}`);

function createColumns(
  cst: Program,
  tableName: string,
  statement: CreateTableStmt,
  sql: string[],
) {
  if (!statement.columns) {
    return;
  }
  let columns: string[] = [];
  for (let [index, item] of statement.columns.expr.items.entries()) {
    if (item.type !== 'column_definition') {
      continue;
    }
    let column: string[] = [];
    column.push(index === 0 ? INDENT.substring(1) : INDENT, item.name.name);
    if (item.dataType?.type === 'named_data_type') {
      let dataTypeName = Array.isArray(item.dataType.nameKw)
        ? item.dataType.nameKw[0]
        : item.dataType.nameKw;
      switch (dataTypeName.name) {
        case 'CHARACTER':
          column.push('TEXT');
          break;
        case 'JSONB':
          column.push('BLOB');
          break;
        case 'BOOLEAN':
          column.push('BOOLEAN');
          break;
        case 'INTEGER':
          column.push('INTEGER');
          break;
        case 'UUID':
          column.push('INTEGER');
          break;
      }
    }
    for (let constraint of item.constraints) {
      switch (constraint.type) {
        case 'constraint_not_null':
          column.push('NOT NULL');
          break;
        case 'constraint_primary_key':
          column.push('PRIMARY KEY');
          break;
        case 'constraint_default':
          if ('value' in constraint.expr) {
            column.push('DEFAULT', String(constraint.expr.value));
            break;
          } else if (
            constraint.expr.type === 'cast_operator_expr' &&
            'expr' in constraint.expr &&
            'text' in constraint.expr.expr
          ) {
            column.push('DEFAULT', String(constraint.expr.expr.text));
            break;
          } else if (
            constraint.expr.type === 'func_call' &&
            'name' in constraint.expr &&
            constraint.expr.name.type === 'identifier' &&
            constraint.expr.name.name === 'gen_random_uuid'
          ) {
            // Skip default value for UUID columns - using AUTOINCREMENT instead
            break;
          } else {
            throw new Error(
              `Don't know how to serialize default value constraint for expression type '${constraint.expr.type}'`,
            );
          }
        default:
          throw new Error(
            `Don't know how to serialize constraint ${constraint.type} for column '${item.name.name}'`,
          );
      }
    }

    // Check if this is a UUID column that will become a primary key via table-level constraint
    if (item.dataType?.type === 'named_data_type') {
      let dataTypeName = Array.isArray(item.dataType.nameKw)
        ? item.dataType.nameKw[0]
        : item.dataType.nameKw;
      if (
        dataTypeName.name === 'UUID' &&
        isUuidPrimaryKey(cst, tableName, item.name.name)
      ) {
        // For UUID primary keys, use INTEGER PRIMARY KEY AUTOINCREMENT
        // Keep the indentation and column name, replace the rest
        column.push('PRIMARY', 'KEY', 'AUTOINCREMENT');
      }
    }

    columns.push(column.join(' '));
  }
  let pkConstraint = makePrimaryKeyConstraint(cst, tableName);
  sql.push([...columns, ...(pkConstraint ? [pkConstraint] : [])].join(',\n'));
}

function makePrimaryKeyConstraint(
  cst: Program,
  tableName: string,
): string | undefined {
  let alterTableStmts = cst.statements.filter(
    (s) =>
      s.type === 'alter_table_stmt' &&
      s.table.type === 'table_without_inheritance' &&
      s.table.table.type === 'member_expr' &&
      s.table.table.property.type === 'identifier' &&
      s.table.table.property.name === tableName,
  ) as AlterTableStmt[];
  let pkConstraint: string[] = [];
  for (let alterTableStmt of alterTableStmts) {
    for (let item of alterTableStmt.actions.items) {
      if (item.type === 'alter_action_add_constraint') {
        switch (item.constraint.type) {
          case 'constraint_primary_key': {
            if (pkConstraint.length > 0) {
              throw new Error(
                `encountered multiple primary key constraints for table ${tableName}`,
              );
            }
            if (item.constraint.columns) {
              let columns: string[] = [];
              if (item.constraint.columns.type === 'paren_expr') {
                for (let column of item.constraint.columns.expr.items) {
                  if (
                    column.type === 'index_specification' &&
                    column.expr.type === 'identifier'
                  ) {
                    columns.push(column.expr.name);
                  }
                }
              } else {
                throw new Error(
                  `Don't know how to serialize constraint ${item.constraint.type} for table '${tableName}'`,
                );
              }
              if (columns.length > 0) {
                // Skip table-level primary key constraint if it's a single UUID column
                // (handled at column level with INTEGER PRIMARY KEY AUTOINCREMENT)
                let isSingleUuidPrimaryKey =
                  columns.length === 1 &&
                  isUuidPrimaryKey(cst, tableName, columns[0]);

                if (!isSingleUuidPrimaryKey) {
                  pkConstraint.push(
                    INDENT,
                    'PRIMARY KEY (',
                    columns.join(', '),
                    ')',
                  );
                }
              }
            }
            break;
          }
          default:
            throw new Error(
              `Don't know how to serialize constraint ${item.constraint.type} for table '${tableName}'`,
            );
        }
      }
    }
  }
  if (pkConstraint.length === 0) {
    return undefined;
  }
  return pkConstraint.join(' ');
}

function isUuidPrimaryKey(
  cst: Program,
  tableName: string,
  columnName: string,
): boolean {
  let isUuid = false;
  let isPrimaryKey = false;

  // First check column-level constraints
  for (let statement of cst.statements) {
    if (statement.type === 'create_table_stmt') {
      let statementTableName = '';
      if (
        statement.name.type === 'member_expr' &&
        statement.name.property.type === 'identifier'
      ) {
        statementTableName = statement.name.property.name;
      }

      if (statementTableName === tableName && statement.columns) {
        for (let item of statement.columns.expr.items) {
          if (
            item.type === 'column_definition' &&
            item.name.name === columnName
          ) {
            // Check if it's a UUID type
            if (item.dataType?.type === 'named_data_type') {
              let dataTypeName = Array.isArray(item.dataType.nameKw)
                ? item.dataType.nameKw[0]
                : item.dataType.nameKw;
              if (dataTypeName.name === 'UUID') {
                isUuid = true;
              }
            }

            // Check for column-level primary key constraint
            for (let constraint of item.constraints) {
              if (constraint.type === 'constraint_primary_key') {
                isPrimaryKey = true;
                break;
              }
            }
          }
        }
      }
    }
  }

  // Then check table-level primary key constraints
  if (!isPrimaryKey) {
    for (let statement of cst.statements) {
      if (statement.type === 'alter_table_stmt') {
        let alterTableName = '';
        if (
          statement.table.type === 'table_without_inheritance' &&
          statement.table.table.type === 'member_expr' &&
          statement.table.table.property.type === 'identifier'
        ) {
          alterTableName = statement.table.table.property.name;
        }

        if (alterTableName === tableName) {
          for (let item of statement.actions.items) {
            if (item.type === 'alter_action_add_constraint') {
              if (item.constraint.type === 'constraint_primary_key') {
                if (item.constraint.columns?.type === 'paren_expr') {
                  for (let column of item.constraint.columns.expr.items) {
                    if (
                      column.type === 'index_specification' &&
                      column.expr.type === 'identifier' &&
                      column.expr.name === columnName
                    ) {
                      isPrimaryKey = true;
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return isUuid && isPrimaryKey;
}

// This strips out all the things that our SQL AST chokes on (it's still in an
// experimental phase for postgresql)
function prepareDump(sql: string): string {
  let result = sql
    .replace(/\s*SET\s[^;].*;/gm, '')
    .replace(/\s*CREATE\sTYPE\s[^;]*;/gm, '');
  return result;
}

function getSchemaFilename(): string {
  let files = readdirSync(migrationsDir);
  let lastFile = files
    .filter((f) => f !== '.eslintrc.js')
    .sort()
    .pop()!;
  return `${lastFile.replace(/_.*/, '')}_schema.sql`;
}
