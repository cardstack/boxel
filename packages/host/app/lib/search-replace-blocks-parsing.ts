export interface ParsedCodeContent {
  fileUrl: string | null;
  code: string; // only code, without the file url and diff markers (for the code editor)
  searchStartLine: number | null;
  searchEndLine: number | null;
  replaceStartLine: number | null;
  replaceEndLine: number | null;
  contentWithoutFileUrl: string | null; // diff markers and code, but file url is removed
}

// This function will take an input from a code block that the LLM responded with,
// and it will try to recognize this pattern:

// // File url: https://example.com/file.txt
// // File url: https://example.com/file.txt
// <<<<<<< SEARCH
// code to search
// =======
// code to replace
// >>>>>>> REPLACE

// It will parse it and return an object with the following properties:
// - fileUrl: needed for ApplySearchReplaceBlockCommand
// - contentWithoutFileUrl: needed for ApplySearchReplaceBlockCommand
// - code: code, without the file url and diff markers (this is fed into the code editor)
// - searchStartLine: where the search block starts (for code editor diff decorations)
// - searchEndLine: where the search block ends (for code editor diff decorations)
// - replaceStartLine: where the replace block starts (for code editor diff decorations)
// - replaceEndLine: where the replace block ends (for code editor diff decorations)

// This code was mostly generated by https://x.ai/grok by feeding it tests from code-patching-test.ts, and edited to fix edge cases.
export function parseCodeContent(input: string): ParsedCodeContent {
  const lines = input.split('\n');

  // Extract file URL if present
  let fileUrl: string | null = null;
  const fileUrlIndex = lines.findIndex((line) =>
    line.startsWith('// File url: '),
  );
  if (fileUrlIndex !== -1) {
    fileUrl = lines[fileUrlIndex].substring('// File url: '.length).trim();
  }

  let contentWithoutFileUrl;
  if (fileUrl) {
    contentWithoutFileUrl = lines.slice(fileUrlIndex + 1).join('\n');
  }

  // Find diff markers
  const searchStart = lines.indexOf('<<<<<<< SEARCH');
  const separator = lines.indexOf('=======', searchStart + 1);
  const replaceEnd = lines.indexOf('>>>>>>> REPLACE', separator + 1);
  const hasCompleteDiff =
    searchStart !== -1 &&
    separator !== -1 &&
    replaceEnd !== -1 &&
    searchStart < separator &&
    separator < replaceEnd;

  let codeLines: string[] = [];
  let searchLines: number[] = [];
  let replaceLines: number[] = [];

  if (hasCompleteDiff) {
    // Complete diff: extract search and replace blocks
    const searchCodeLines = lines.slice(searchStart + 1, separator);
    const replaceCodeLines = lines.slice(separator + 1, replaceEnd);
    codeLines = [...searchCodeLines, ...replaceCodeLines];
    searchLines = Array.from({ length: searchCodeLines.length }, (_, i) => i);
    replaceLines = Array.from(
      { length: replaceCodeLines.length },
      (_, i) => i + searchCodeLines.length,
    );
  } else if (searchStart !== -1 && separator !== -1) {
    // Unfinished replace block: search block and partial replace block
    const searchCodeLines = lines.slice(searchStart + 1, separator);
    const replaceCodeLines = lines.slice(separator + 1);
    codeLines = [...searchCodeLines, ...replaceCodeLines];
    searchLines = Array.from({ length: searchCodeLines.length }, (_, i) => i);
    replaceLines = Array.from(
      { length: replaceCodeLines.length },
      (_, i) => i + searchCodeLines.length,
    );
  } else if (searchStart !== -1) {
    // Unfinished search block: only search block present
    const searchCodeLines = lines.slice(searchStart + 1);
    codeLines = searchCodeLines;
    searchLines = Array.from({ length: searchCodeLines.length }, (_, i) => i);
  } else {
    // No diff markers: return all lines except file URL
    codeLines = lines.filter((_, i) => i !== fileUrlIndex);
  }

  // Remove trailing empty lines from codeLines and adjust line arrays
  while (
    codeLines.length > 0 &&
    codeLines[codeLines.length - 1].trim() === ''
  ) {
    codeLines.pop();
    if (replaceLines.length > 0) {
      replaceLines.pop();
    } else if (searchLines.length > 0) {
      searchLines.pop();
    }
  }

  // Normalize leading whitespace if codeLines are not empty
  if (codeLines.length > 0) {
    const minLeadingSpaces = Math.min(
      ...codeLines
        .filter((line) => line.trim() !== '')
        .map((line) => line.match(/^\s*/)?.[0].length || 0),
    );
    codeLines = codeLines.map((line) => line.substring(minLeadingSpaces));
  }

  // Join lines into final code string
  const code = codeLines.join('\n');

  // Set line numbers (1-based for output)
  const searchStartLine = searchLines.length > 0 ? searchLines[0] + 1 : null;
  const searchEndLine =
    searchLines.length > 0 ? searchLines[searchLines.length - 1] + 1 : null;
  const replaceStartLine = replaceLines.length > 0 ? replaceLines[0] + 1 : null;
  const replaceEndLine =
    replaceLines.length > 0 ? replaceLines[replaceLines.length - 1] + 1 : null;

  return {
    fileUrl,
    code,
    searchStartLine,
    searchEndLine,
    replaceStartLine,
    replaceEndLine,
    contentWithoutFileUrl: contentWithoutFileUrl ?? null,
  };
}
